import { Discussion, EnhancedDiscussion } from '../engine/discussion.js';
import { ConsensusMetrics, isDynamicRoundsEnabled } from '../types/consensus.js';

export interface WriterConfig {
  language: string;
  timestamp: string;
  prompt: string;
  includeAcceptanceCriteria?: boolean;
}

export async function writeDiscussionMarkdown(
  discussion: Discussion | EnhancedDiscussion,
  config: WriterConfig
): Promise<string> {
  const { language, timestamp, prompt } = config;
  const isPortuguese = language === 'pt' || language === 'pt-BR';

  const lines: string[] = [];

  // Header
  lines.push(isPortuguese ? '# Discussão da Mesa Redonda' : '# Roundtable Discussion');
  lines.push('');
  lines.push(`**${isPortuguese ? 'Data/Hora' : 'Timestamp'}:** ${timestamp}`);
  lines.push(`**${isPortuguese ? 'Prompt de Entrada' : 'Input Prompt'}:** ${prompt}`);
  lines.push(`**${isPortuguese ? 'Idioma' : 'Language'}:** ${language}`);
  lines.push('');

  // Executive Summary (new section before participants)
  lines.push(...await generateExecutiveSummary(discussion, isPortuguese));

  // Participants
  lines.push(`## ${isPortuguese ? 'Participantes' : 'Participants'}`);
  lines.push('');
  lines.push(isPortuguese 
    ? '| Nome | Papel | Objetivos |'
    : '| Name | Role | Objectives |'
  );
  lines.push('|------|------|------------|');

  for (const participant of discussion.participants) {
    const objectives = participant.objectives.slice(0, 2).join('; ');
    lines.push(`| ${participant.name} | ${participant.role} | ${objectives} |`);
  }
  lines.push('');

  // Discussion Rounds
  lines.push(`## ${isPortuguese ? 'Transcrição da Discussão' : 'Discussion Transcript'}`);
  lines.push('');

  let currentRound = 0;
  for (const turn of discussion.rounds) {
    if (turn.round !== currentRound) {
      currentRound = turn.round;
      lines.push(`### ${isPortuguese ? 'Rodada' : 'Round'} ${currentRound}`);
      lines.push('');
    }

    lines.push(`**${turn.speaker}** (${turn.role}):`);
    lines.push('');
    lines.push(`> ${turn.content}`);
    lines.push('');
  }

  // Decisions
  lines.push(`## ${isPortuguese ? 'Decisões e Justificativas' : 'Decisions & Rationale'}`);
  lines.push('');

  for (let i = 0; i < discussion.decisions.length; i++) {
    lines.push(`${i + 1}. ${discussion.decisions[i]}`);
  }
  lines.push('');

  // Next Steps
  lines.push(`## ${isPortuguese ? 'Próximos Passos' : 'Next Steps'}`);
  lines.push('');

  for (let i = 0; i < discussion.nextSteps.length; i++) {
    lines.push(`${i + 1}. ${discussion.nextSteps[i]}`);
  }
  lines.push('');

  // Add consensus metrics if available (for enhanced discussions)
  if (isEnhancedDiscussion(discussion) && discussion.consensusHistory.length > 0) {
    lines.push(...generateConsensusSection(discussion, isPortuguese));
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(isPortuguese
    ? '*Documento gerado pelo PentaForge MCP Server*'
    : '*Document generated by PentaForge MCP Server*'
  );

  return lines.join('\n');
}

/**
 * Type guard to check if discussion is enhanced with consensus data
 */
function isEnhancedDiscussion(discussion: Discussion | EnhancedDiscussion): discussion is EnhancedDiscussion {
  return 'consensusHistory' in discussion && 'consensusReached' in discussion;
}

/**
 * Generates consensus metrics section for enhanced discussions
 */
function generateConsensusSection(discussion: EnhancedDiscussion, isPortuguese: boolean): string[] {
  const lines: string[] = [];
  
  // Consensus Overview
  lines.push(`## ${isPortuguese ? 'Métricas de Consenso' : 'Consensus Metrics'}`);
  lines.push('');
  
  const finalConsensus = discussion.consensusHistory[discussion.consensusHistory.length - 1];
  const isDynamic = isDynamicRoundsEnabled(discussion.config);
  
  if (isDynamic) {
    lines.push(`**${isPortuguese ? 'Modo' : 'Mode'}:** ${isPortuguese ? 'Rodadas Dinâmicas' : 'Dynamic Rounds'}`);
    lines.push(`**${isPortuguese ? 'Consenso Alcançado' : 'Consensus Reached'}:** ${discussion.consensusReached ? (isPortuguese ? 'Sim' : 'Yes') : (isPortuguese ? 'Não' : 'No')}`);
    lines.push(`**${isPortuguese ? 'Total de Rodadas' : 'Total Rounds'}:** ${discussion.currentRound}`);
    
    if (finalConsensus) {
      lines.push(`**${isPortuguese ? 'Pontuação Final de Acordo' : 'Final Agreement Score'}:** ${finalConsensus.agreementScore}%`);
      lines.push(`**${isPortuguese ? 'Nível de Confiança' : 'Confidence Level'}:** ${finalConsensus.confidenceLevel}%`);
      lines.push(`**${isPortuguese ? 'Fase da Discussão' : 'Discussion Phase'}:** ${translatePhase(finalConsensus.discussionPhase, isPortuguese)}`);
    }
  } else {
    lines.push(`**${isPortuguese ? 'Modo' : 'Mode'}:** ${isPortuguese ? 'Rodadas Fixas (3 rodadas)' : 'Fixed Rounds (3 rounds)'}`);
    lines.push(`**${isPortuguese ? 'Consenso' : 'Consensus'}:** ${isPortuguese ? 'Assumido (compatibilidade)' : 'Assumed (compatibility)'}`);
  }
  
  lines.push('');
  
  // Consensus Evolution (only for dynamic rounds)
  if (isDynamic && discussion.consensusHistory.length > 1) {
    lines.push(`### ${isPortuguese ? 'Evolução do Consenso' : 'Consensus Evolution'}`);
    lines.push('');
    
    lines.push(isPortuguese 
      ? '| Rodada | Acordo (%) | Confiança (%) | Questões Não Resolvidas | Fase |'
      : '| Round | Agreement (%) | Confidence (%) | Unresolved Issues | Phase |'
    );
    lines.push('|--------|------------|---------------|----------------------|-------|');
    
    discussion.consensusHistory.forEach((metrics: any, index: number) => {
      const round = index + 1;
      const issuesCount = metrics.unresolvedIssues.length;
      const phase = translatePhase(metrics.discussionPhase, isPortuguese);
      lines.push(`| ${round} | ${metrics.agreementScore}% | ${metrics.confidenceLevel}% | ${issuesCount} | ${phase} |`);
    });
    
    lines.push('');
  }
  
  // Final State Analysis
  if (finalConsensus) {
    lines.push(`### ${isPortuguese ? 'Análise Final' : 'Final Analysis'}`);
    lines.push('');
    
    if (finalConsensus.unresolvedIssues.length > 0) {
      lines.push(`**${isPortuguese ? 'Questões Não Resolvidas' : 'Unresolved Issues'}:**`);
      finalConsensus.unresolvedIssues.forEach((issue: string) => {
        lines.push(`- ${issue}`);
      });
      lines.push('');
    }
    
    if (finalConsensus.conflictingPositions.size > 0) {
      lines.push(`**${isPortuguese ? 'Posições Conflitantes' : 'Conflicting Positions'}:**`);
      finalConsensus.conflictingPositions.forEach((positions: string[], role: string) => {
        lines.push(`- **${role}:** ${positions.join(', ')}`);
      });
      lines.push('');
    }
    
    if (finalConsensus.unresolvedIssues.length === 0 && finalConsensus.conflictingPositions.size === 0) {
      lines.push(isPortuguese 
        ? `✅ **Consenso Completo:** Todas as questões foram resolvidas e não há conflitos pendentes.`
        : `✅ **Complete Consensus:** All issues resolved and no pending conflicts.`
      );
      lines.push('');
    }
  }
  
  return lines;
}

/**
 * Translates discussion phase to appropriate language
 */
function translatePhase(phase: ConsensusMetrics['discussionPhase'], isPortuguese: boolean): string {
  if (isPortuguese) {
    switch (phase) {
      case 'exploration': return 'Exploração';
      case 'alignment': return 'Alinhamento';
      case 'resolution': return 'Resolução';
      case 'finalization': return 'Finalização';
      default: return phase;
    }
  }

  // English - just capitalize first letter
  return phase.charAt(0).toUpperCase() + phase.slice(1);
}

/**
 * Generates executive summary section with decisions and alternatives
 */
async function generateExecutiveSummary(discussion: Discussion | EnhancedDiscussion, isPortuguese: boolean): Promise<string[]> {
  const lines: string[] = [];

  // Section header
  lines.push(`## ${isPortuguese ? 'Resumo Executivo' : 'Executive Summary'}`);
  lines.push('');

  // Extract key decisions and alternatives from discussion
  const analysis = analyzeDiscussionDecisions(discussion, isPortuguese);

  // Overview
  lines.push(`### ${isPortuguese ? 'Visão Geral' : 'Overview'}`);
  lines.push('');
  lines.push(analysis.overview);
  lines.push('');

  // Key decisions with alternatives
  if (analysis.decisions.length > 0) {
    lines.push(`### ${isPortuguese ? 'Decisões Tomadas e Alternativas Consideradas' : 'Decisions Made and Alternatives Considered'}`);
    lines.push('');

    analysis.decisions.forEach((decision, index) => {
      lines.push(`#### ${index + 1}. ${decision.topic}`);
      lines.push('');

      // Final decision
      lines.push(`**${isPortuguese ? 'Decisão Final' : 'Final Decision'}:** ${decision.finalChoice}`);
      lines.push('');

      // Rationale
      if (decision.rationale) {
        lines.push(`**${isPortuguese ? 'Justificativa' : 'Rationale'}:** ${decision.rationale}`);
        lines.push('');
      }

      // Alternatives considered
      if (decision.alternatives.length > 0) {
        lines.push(`**${isPortuguese ? 'Alternativas Consideradas e Descartadas' : 'Alternatives Considered and Discarded'}:**`);
        decision.alternatives.forEach(alt => {
          lines.push(`- **${alt.option}**: ${alt.reason}`);
        });
        lines.push('');
      }
    });
  }

  // Discarded options
  if (analysis.discarded.length > 0) {
    lines.push(`### ${isPortuguese ? 'Opções Descartadas Durante a Discussão' : 'Options Discarded During Discussion'}`);
    lines.push('');

    analysis.discarded.forEach(item => {
      lines.push(`- **${item.option}**: ${item.reason}`);
    });
    lines.push('');
  }

  return lines;
}

/**
 * Analyzes discussion rounds to extract decisions, alternatives, and rationale
 */
function analyzeDiscussionDecisions(discussion: Discussion | EnhancedDiscussion, isPortuguese: boolean): {
  overview: string;
  decisions: Array<{
    topic: string;
    finalChoice: string;
    rationale: string;
    alternatives: Array<{ option: string; reason: string }>;
  }>;
  discarded: Array<{ option: string; reason: string }>;
} {
  const rounds = discussion.rounds;

  // Extract technology/approach mentions and their evolution
  const mentions = extractTechnologyMentions(rounds);
  const decisions = buildDecisionTree(mentions, discussion.decisions, isPortuguese);
  const discarded = extractDiscardedOptions(rounds, decisions, isPortuguese);

  // Generate overview
  const overview = generateOverview(discussion, isPortuguese);

  return {
    overview,
    decisions,
    discarded
  };
}

/**
 * Extracts mentions of technologies, approaches, and alternatives from discussion
 */
function extractTechnologyMentions(rounds: any[]): Map<string, Array<{ speaker: string; content: string; round: number; sentiment: 'positive' | 'negative' | 'neutral' }>> {
  const mentions = new Map<string, Array<{ speaker: string; content: string; round: number; sentiment: 'positive' | 'negative' | 'neutral' }>>();

  // Keywords that indicate technology/approach mentions
  const techIndicators = [
    'kafka', 'rabbitmq', 'redis', 'postgresql', 'mysql', 'mongodb', 'dynamodb',
    'react', 'vue', 'angular', 'nextjs', 'express', 'fastapi', 'spring',
    'docker', 'kubernetes', 'aws', 'azure', 'gcp', 'microservices', 'monolith',
    'rest', 'graphql', 'grpc', 'oauth', 'jwt', 'saml', 'websocket',
    'typescript', 'javascript', 'python', 'java', 'go', 'rust'
  ];

  rounds.forEach(turn => {
    const content = turn.content.toLowerCase();

    techIndicators.forEach(tech => {
      if (content.includes(tech)) {
        // Determine sentiment
        let sentiment: 'positive' | 'negative' | 'neutral' = 'neutral';

        const positiveWords = ['recommend', 'suggest', 'prefer', 'better', 'ideal', 'advantage', 'benefit', 'recomendo', 'sugiro', 'prefiro', 'melhor', 'ideal', 'vantagem', 'benefício'];
        const negativeWords = ['avoid', 'problem', 'issue', 'concern', 'drawback', 'limitation', 'evitar', 'problema', 'questão', 'preocupação', 'desvantagem', 'limitação'];

        if (positiveWords.some(word => content.includes(word))) {
          sentiment = 'positive';
        } else if (negativeWords.some(word => content.includes(word))) {
          sentiment = 'negative';
        }

        if (!mentions.has(tech)) {
          mentions.set(tech, []);
        }

        mentions.get(tech)!.push({
          speaker: turn.role,
          content: turn.content,
          round: turn.round,
          sentiment
        });
      }
    });
  });

  return mentions;
}

/**
 * Builds decision tree from mentions and final decisions
 */
function buildDecisionTree(
  mentions: Map<string, Array<{ speaker: string; content: string; round: number; sentiment: 'positive' | 'negative' | 'neutral' }>>,
  finalDecisions: string[],
  isPortuguese: boolean
): Array<{
  topic: string;
  finalChoice: string;
  rationale: string;
  alternatives: Array<{ option: string; reason: string }>;
}> {
  const decisions: Array<{
    topic: string;
    finalChoice: string;
    rationale: string;
    alternatives: Array<{ option: string; reason: string }>;
  }> = [];

  // Group related technologies (e.g., Kafka vs RabbitMQ)
  const groups = groupRelatedTechnologies(mentions);

  groups.forEach(group => {
    // Find which one was chosen (appears in final decisions with positive sentiment)
    const chosen = group.technologies.find(tech => {
      const techMentions = mentions.get(tech) || [];
      const hasPositive = techMentions.some(m => m.sentiment === 'positive');
      const inDecisions = finalDecisions.some(d => d.toLowerCase().includes(tech));
      return hasPositive && inDecisions;
    });

    if (chosen) {
      const chosenMentions = mentions.get(chosen) || [];
      const rationale = extractRationale(chosenMentions, isPortuguese);

      const alternatives = group.technologies
        .filter(tech => tech !== chosen)
        .map(tech => {
          const techMentions = mentions.get(tech) || [];
          const reason = extractDiscardReason(techMentions, isPortuguese);
          return { option: tech.toUpperCase(), reason };
        })
        .filter(alt => alt.reason.length > 0);

      decisions.push({
        topic: group.category,
        finalChoice: chosen.toUpperCase(),
        rationale,
        alternatives
      });
    }
  });

  return decisions;
}

/**
 * Groups related technologies by category
 */
function groupRelatedTechnologies(mentions: Map<string, any[]>): Array<{ category: string; technologies: string[] }> {
  const groups: Array<{ category: string; technologies: string[] }> = [];

  const categories = {
    'Message Broker': ['kafka', 'rabbitmq'],
    'Database': ['postgresql', 'mysql', 'mongodb', 'dynamodb', 'redis'],
    'Frontend Framework': ['react', 'vue', 'angular', 'nextjs'],
    'Backend Framework': ['express', 'fastapi', 'spring'],
    'Authentication': ['oauth', 'jwt', 'saml'],
    'API Protocol': ['rest', 'graphql', 'grpc'],
    'Programming Language': ['typescript', 'javascript', 'python', 'java', 'go', 'rust'],
    'Infrastructure': ['docker', 'kubernetes'],
    'Cloud Provider': ['aws', 'azure', 'gcp'],
    'Architecture': ['microservices', 'monolith']
  };

  Object.entries(categories).forEach(([category, techs]) => {
    const foundTechs = techs.filter(tech => mentions.has(tech));
    if (foundTechs.length > 0) {
      groups.push({ category, technologies: foundTechs });
    }
  });

  return groups;
}

/**
 * Extracts rationale for chosen technology
 */
function extractRationale(mentions: Array<{ speaker: string; content: string; round: number; sentiment: 'positive' | 'negative' | 'neutral' }>, isPortuguese: boolean): string {
  const positiveMentions = mentions.filter(m => m.sentiment === 'positive');

  if (positiveMentions.length === 0) {
    return isPortuguese ? 'Consenso da equipe' : 'Team consensus';
  }

  // Extract sentences with reasoning
  const reasoningIndicators = isPortuguese
    ? ['porque', 'devido', 'uma vez que', 'considerando', 'já que', 'vantagem', 'benefício', 'permite', 'garante']
    : ['because', 'since', 'due to', 'given that', 'considering', 'advantage', 'benefit', 'allows', 'ensures'];

  const rationales: string[] = [];

  positiveMentions.forEach(mention => {
    const sentences = mention.content.split(/[.!?]+/);
    sentences.forEach(sentence => {
      if (reasoningIndicators.some(indicator => sentence.toLowerCase().includes(indicator))) {
        rationales.push(sentence.trim());
      }
    });
  });

  return rationales.length > 0
    ? rationales[0]
    : (isPortuguese ? 'Recomendado pela equipe técnica' : 'Recommended by technical team');
}

/**
 * Extracts reason for discarding alternative
 */
function extractDiscardReason(mentions: Array<{ speaker: string; content: string; round: number; sentiment: 'positive' | 'negative' | 'neutral' }>, isPortuguese: boolean): string {
  const negativeMentions = mentions.filter(m => m.sentiment === 'negative');

  if (negativeMentions.length === 0) {
    return '';
  }

  const reasoningIndicators = isPortuguese
    ? ['problema', 'limitação', 'desvantagem', 'complexidade', 'custo', 'dificulta', 'não atende']
    : ['problem', 'limitation', 'drawback', 'complexity', 'cost', 'difficult', 'does not meet'];

  const reasons: string[] = [];

  negativeMentions.forEach(mention => {
    const sentences = mention.content.split(/[.!?]+/);
    sentences.forEach(sentence => {
      if (reasoningIndicators.some(indicator => sentence.toLowerCase().includes(indicator))) {
        reasons.push(sentence.trim());
      }
    });
  });

  return reasons.length > 0
    ? reasons[0]
    : (isPortuguese ? 'Não atende aos requisitos' : 'Does not meet requirements');
}

/**
 * Extracts discarded options from discussion
 */
function extractDiscardedOptions(
  _rounds: any[],
  decisions: Array<{ topic: string; finalChoice: string; alternatives: Array<{ option: string; reason: string }> }>,
  _isPortuguese: boolean
): Array<{ option: string; reason: string }> {
  const discarded: Array<{ option: string; reason: string }> = [];

  // Collect all alternatives already captured in decisions
  decisions.forEach(decision => {
    discarded.push(...decision.alternatives);
  });

  return discarded;
}

/**
 * Generates overview of discussion
 */
function generateOverview(discussion: Discussion | EnhancedDiscussion, isPortuguese: boolean): string {
  const totalRounds = discussion.rounds.length > 0 ? Math.max(...discussion.rounds.map(r => r.round)) : 0;
  const participantCount = discussion.participants.length;
  const decisionCount = discussion.decisions.length;

  if (isPortuguese) {
    return `A discussão envolveu ${participantCount} participantes ao longo de ${totalRounds} rodadas, resultando em ${decisionCount} decisões principais. A equipe analisou diferentes alternativas técnicas e de negócio para cada aspecto do projeto, considerando trade-offs entre complexidade, custo, performance e manutenibilidade.`;
  }

  return `The discussion involved ${participantCount} participants across ${totalRounds} rounds, resulting in ${decisionCount} key decisions. The team analyzed different technical and business alternatives for each aspect of the project, considering trade-offs between complexity, cost, performance, and maintainability.`;
}